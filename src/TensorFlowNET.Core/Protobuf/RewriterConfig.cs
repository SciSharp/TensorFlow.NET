// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: tensorflow/core/protobuf/rewriter_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow {

  /// <summary>Holder for reflection information generated from tensorflow/core/protobuf/rewriter_config.proto</summary>
  public static partial class RewriterConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for tensorflow/core/protobuf/rewriter_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static RewriterConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci50ZW5zb3JmbG93L2NvcmUvcHJvdG9idWYvcmV3cml0ZXJfY29uZmlnLnBy",
            "b3RvEgp0ZW5zb3JmbG93Gip0ZW5zb3JmbG93L2NvcmUvZnJhbWV3b3JrL2F0",
            "dHJfdmFsdWUucHJvdG8aLnRlbnNvcmZsb3cvY29yZS9wcm90b2J1Zi92ZXJp",
            "Zmllcl9jb25maWcucHJvdG8iOwoTQXV0b1BhcmFsbGVsT3B0aW9ucxIOCgZl",
            "bmFibGUYASABKAgSFAoMbnVtX3JlcGxpY2FzGAIgASgFIisKFlNjb3BlZEFs",
            "bG9jYXRvck9wdGlvbnMSEQoJZW5hYmxlX29wGAEgAygJIuETCg5SZXdyaXRl",
            "ckNvbmZpZxJDChVjcHVfbGF5b3V0X2NvbnZlcnNpb24YMiABKA4yJC50ZW5z",
            "b3JmbG93LlJld3JpdGVyQ29uZmlnLkNwdUxheW91dBI7ChBsYXlvdXRfb3B0",
            "aW1pemVyGAEgASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dn",
            "bGUSOwoQY29uc3RhbnRfZm9sZGluZxgDIAEoDjIhLnRlbnNvcmZsb3cuUmV3",
            "cml0ZXJDb25maWcuVG9nZ2xlEj0KEnNoYXBlX29wdGltaXphdGlvbhgNIAEo",
            "DjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xlEjQKCXJlbWFw",
            "cGluZxgOIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xl",
            "EkYKG2NvbW1vbl9zdWJncmFwaF9lbGltaW5hdGlvbhgYIAEoDjIhLnRlbnNv",
            "cmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkIKF2FyaXRobWV0aWNfb3B0",
            "aW1pemF0aW9uGAcgASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5U",
            "b2dnbGUSQgoXZGVwZW5kZW5jeV9vcHRpbWl6YXRpb24YCCABKA4yIS50ZW5z",
            "b3JmbG93LlJld3JpdGVyQ29uZmlnLlRvZ2dsZRI8ChFsb29wX29wdGltaXph",
            "dGlvbhgJIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xl",
            "EkAKFWZ1bmN0aW9uX29wdGltaXphdGlvbhgKIAEoDjIhLnRlbnNvcmZsb3cu",
            "UmV3cml0ZXJDb25maWcuVG9nZ2xlEjkKDmRlYnVnX3N0cmlwcGVyGAsgASgO",
            "MiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSHQoVZGlzYWJs",
            "ZV9tb2RlbF9wcnVuaW5nGAIgASgIEkgKHXNjb3BlZF9hbGxvY2F0b3Jfb3B0",
            "aW1pemF0aW9uGA8gASgOMiEudGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5U",
            "b2dnbGUSQwoYcGluX3RvX2hvc3Rfb3B0aW1pemF0aW9uGBIgASgOMiEudGVu",
            "c29yZmxvdy5SZXdyaXRlckNvbmZpZy5Ub2dnbGUSQgoXaW1wbGVtZW50YXRp",
            "b25fc2VsZWN0b3IYFiABKA4yIS50ZW5zb3JmbG93LlJld3JpdGVyQ29uZmln",
            "LlRvZ2dsZRI/ChRhdXRvX21peGVkX3ByZWNpc2lvbhgXIAEoDjIhLnRlbnNv",
            "cmZsb3cuUmV3cml0ZXJDb25maWcuVG9nZ2xlEkMKGGF1dG9fbWl4ZWRfcHJl",
            "Y2lzaW9uX21rbBgZIAEoDjIhLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcu",
            "VG9nZ2xlEh4KFmRpc2FibGVfbWV0YV9vcHRpbWl6ZXIYEyABKAgSQAoVdXNl",
            "X3BsdWdpbl9vcHRpbWl6ZXJzGBwgASgOMiEudGVuc29yZmxvdy5SZXdyaXRl",
            "ckNvbmZpZy5Ub2dnbGUSTwoZbWV0YV9vcHRpbWl6ZXJfaXRlcmF0aW9ucxgM",
            "IAEoDjIsLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuTnVtSXRlcmF0aW9u",
            "c1R5cGUSFwoPbWluX2dyYXBoX25vZGVzGBEgASgFEjsKM2V4cGVyaW1lbnRh",
            "bF9kaXNhYmxlX2NvbXByZXNzZWRfdGVuc29yX29wdGltaXphdGlvbhgaIAEo",
            "CBI7CjNleHBlcmltZW50YWxfZGlzYWJsZV9mb2xkaW5nX3F1YW50aXphdGlv",
            "bl9lbXVsYXRpb24YGyABKAgSQgoTbWVtb3J5X29wdGltaXphdGlvbhgEIAEo",
            "DjIlLnRlbnNvcmZsb3cuUmV3cml0ZXJDb25maWcuTWVtT3B0VHlwZRIvCidt",
            "ZW1vcnlfb3B0aW1pemVyX3RhcmdldF9ub2RlX25hbWVfc2NvcGUYBiABKAkS",
            "IQoZbWV0YV9vcHRpbWl6ZXJfdGltZW91dF9tcxgUIAEoAxI2Cg1hdXRvX3Bh",
            "cmFsbGVsGAUgASgLMh8udGVuc29yZmxvdy5BdXRvUGFyYWxsZWxPcHRpb25z",
            "EiAKGGZhaWxfb25fb3B0aW1pemVyX2Vycm9ycxgVIAEoCBJBChVzY29wZWRf",
            "YWxsb2NhdG9yX29wdHMYECABKAsyIi50ZW5zb3JmbG93LlNjb3BlZEFsbG9j",
            "YXRvck9wdGlvbnMSEgoKb3B0aW1pemVycxhkIAMoCRJLChFjdXN0b21fb3B0",
            "aW1pemVycxjIASADKAsyLy50ZW5zb3JmbG93LlJld3JpdGVyQ29uZmlnLkN1",
            "c3RvbUdyYXBoT3B0aW1pemVyEkQKH2ludGVyX29wdGltaXplcl92ZXJpZmll",
            "cl9jb25maWcYrAIgASgLMhoudGVuc29yZmxvdy5WZXJpZmllckNvbmZpZxJG",
            "CiFwb3N0X29wdGltaXphdGlvbl92ZXJpZmllcl9jb25maWcYrQIgASgLMhou",
            "dGVuc29yZmxvdy5WZXJpZmllckNvbmZpZxrKAQoUQ3VzdG9tR3JhcGhPcHRp",
            "bWl6ZXISDAoEbmFtZRgBIAEoCRJYCg1wYXJhbWV0ZXJfbWFwGAIgAygLMkEu",
            "dGVuc29yZmxvdy5SZXdyaXRlckNvbmZpZy5DdXN0b21HcmFwaE9wdGltaXpl",
            "ci5QYXJhbWV0ZXJNYXBFbnRyeRpKChFQYXJhbWV0ZXJNYXBFbnRyeRILCgNr",
            "ZXkYASABKAkSJAoFdmFsdWUYAiABKAsyFS50ZW5zb3JmbG93LkF0dHJWYWx1",
            "ZToCOAEiNgoGVG9nZ2xlEgsKB0RFRkFVTFQQABIGCgJPThABEgcKA09GRhAC",
            "Eg4KCkFHR1JFU1NJVkUQAyJJCglDcHVMYXlvdXQSGAoUTk9fQ09OVkVSU0lP",
            "Tl9PTl9DUFUQABIQCgxOQ0hXX1RPX05IV0MQARIQCgxOSFdDX1RPX05DSFcQ",
            "AiI8ChFOdW1JdGVyYXRpb25zVHlwZRIVChFERUZBVUxUX05VTV9JVEVSUxAA",
            "EgcKA09ORRABEgcKA1RXTxACIp8BCgpNZW1PcHRUeXBlEhMKD0RFRkFVTFRf",
            "TUVNX09QVBAAEg4KCk5PX01FTV9PUFQQARIKCgZNQU5VQUwQAhIXChNTV0FQ",
            "UElOR19IRVVSSVNUSUNTEAQSHAoYUkVDT01QVVRBVElPTl9IRVVSSVNUSUNT",
            "EAUSGQoVU0NIRURVTElOR19IRVVSSVNUSUNTEAYSDgoKSEVVUklTVElDUxAD",
            "QowBChhvcmcudGVuc29yZmxvdy5mcmFtZXdvcmtCFFJld3JpdGVyQ29uZmln",
            "UHJvdG9zUAFaVWdpdGh1Yi5jb20vdGVuc29yZmxvdy90ZW5zb3JmbG93L3Rl",
            "bnNvcmZsb3cvZ28vY29yZS9wcm90b2J1Zi9mb3JfY29yZV9wcm90b3NfZ29f",
            "cHJvdG/4AQFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.AttrValueReflection.Descriptor, global::Tensorflow.VerifierConfigReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.AutoParallelOptions), global::Tensorflow.AutoParallelOptions.Parser, new[]{ "Enable", "NumReplicas" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.ScopedAllocatorOptions), global::Tensorflow.ScopedAllocatorOptions.Parser, new[]{ "EnableOp" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig), global::Tensorflow.RewriterConfig.Parser, new[]{ "CpuLayoutConversion", "LayoutOptimizer", "ConstantFolding", "ShapeOptimization", "Remapping", "CommonSubgraphElimination", "ArithmeticOptimization", "DependencyOptimization", "LoopOptimization", "FunctionOptimization", "DebugStripper", "DisableModelPruning", "ScopedAllocatorOptimization", "PinToHostOptimization", "ImplementationSelector", "AutoMixedPrecision", "AutoMixedPrecisionMkl", "DisableMetaOptimizer", "UsePluginOptimizers", "MetaOptimizerIterations", "MinGraphNodes", "ExperimentalDisableCompressedTensorOptimization", "ExperimentalDisableFoldingQuantizationEmulation", "MemoryOptimization", "MemoryOptimizerTargetNodeNameScope", "MetaOptimizerTimeoutMs", "AutoParallel", "FailOnOptimizerErrors", "ScopedAllocatorOpts", "Optimizers", "CustomOptimizers", "InterOptimizerVerifierConfig", "PostOptimizationVerifierConfig" }, null, new[]{ typeof(global::Tensorflow.RewriterConfig.Types.Toggle), typeof(global::Tensorflow.RewriterConfig.Types.CpuLayout), typeof(global::Tensorflow.RewriterConfig.Types.NumIterationsType), typeof(global::Tensorflow.RewriterConfig.Types.MemOptType) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer), global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer.Parser, new[]{ "Name", "ParameterMap" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class AutoParallelOptions : pb::IMessage<AutoParallelOptions> {
    private static readonly pb::MessageParser<AutoParallelOptions> _parser = new pb::MessageParser<AutoParallelOptions>(() => new AutoParallelOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoParallelOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions(AutoParallelOptions other) : this() {
      enable_ = other.enable_;
      numReplicas_ = other.numReplicas_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoParallelOptions Clone() {
      return new AutoParallelOptions(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    /// <summary>Field number for the "num_replicas" field.</summary>
    public const int NumReplicasFieldNumber = 2;
    private int numReplicas_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumReplicas {
      get { return numReplicas_; }
      set {
        numReplicas_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoParallelOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoParallelOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      if (NumReplicas != other.NumReplicas) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (NumReplicas != 0) hash ^= NumReplicas.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (NumReplicas != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumReplicas);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (NumReplicas != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumReplicas);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoParallelOptions other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      if (other.NumReplicas != 0) {
        NumReplicas = other.NumReplicas;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
          case 16: {
            NumReplicas = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ScopedAllocatorOptions : pb::IMessage<ScopedAllocatorOptions> {
    private static readonly pb::MessageParser<ScopedAllocatorOptions> _parser = new pb::MessageParser<ScopedAllocatorOptions>(() => new ScopedAllocatorOptions());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScopedAllocatorOptions> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions(ScopedAllocatorOptions other) : this() {
      enableOp_ = other.enableOp_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScopedAllocatorOptions Clone() {
      return new ScopedAllocatorOptions(this);
    }

    /// <summary>Field number for the "enable_op" field.</summary>
    public const int EnableOpFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_enableOp_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> enableOp_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If present, only perform optimization for these ops.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> EnableOp {
      get { return enableOp_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScopedAllocatorOptions);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScopedAllocatorOptions other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!enableOp_.Equals(other.enableOp_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= enableOp_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      enableOp_.WriteTo(output, _repeated_enableOp_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += enableOp_.CalculateSize(_repeated_enableOp_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScopedAllocatorOptions other) {
      if (other == null) {
        return;
      }
      enableOp_.Add(other.enableOp_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            enableOp_.AddEntriesFrom(input, _repeated_enableOp_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Graph rewriting is experimental and subject to change, not covered by any
  /// API stability guarantees.
  /// </summary>
  public sealed partial class RewriterConfig : pb::IMessage<RewriterConfig> {
    private static readonly pb::MessageParser<RewriterConfig> _parser = new pb::MessageParser<RewriterConfig>(() => new RewriterConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RewriterConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.RewriterConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig(RewriterConfig other) : this() {
      cpuLayoutConversion_ = other.cpuLayoutConversion_;
      layoutOptimizer_ = other.layoutOptimizer_;
      constantFolding_ = other.constantFolding_;
      shapeOptimization_ = other.shapeOptimization_;
      remapping_ = other.remapping_;
      commonSubgraphElimination_ = other.commonSubgraphElimination_;
      arithmeticOptimization_ = other.arithmeticOptimization_;
      dependencyOptimization_ = other.dependencyOptimization_;
      loopOptimization_ = other.loopOptimization_;
      functionOptimization_ = other.functionOptimization_;
      debugStripper_ = other.debugStripper_;
      disableModelPruning_ = other.disableModelPruning_;
      scopedAllocatorOptimization_ = other.scopedAllocatorOptimization_;
      pinToHostOptimization_ = other.pinToHostOptimization_;
      implementationSelector_ = other.implementationSelector_;
      autoMixedPrecision_ = other.autoMixedPrecision_;
      autoMixedPrecisionMkl_ = other.autoMixedPrecisionMkl_;
      disableMetaOptimizer_ = other.disableMetaOptimizer_;
      usePluginOptimizers_ = other.usePluginOptimizers_;
      metaOptimizerIterations_ = other.metaOptimizerIterations_;
      minGraphNodes_ = other.minGraphNodes_;
      experimentalDisableCompressedTensorOptimization_ = other.experimentalDisableCompressedTensorOptimization_;
      experimentalDisableFoldingQuantizationEmulation_ = other.experimentalDisableFoldingQuantizationEmulation_;
      memoryOptimization_ = other.memoryOptimization_;
      memoryOptimizerTargetNodeNameScope_ = other.memoryOptimizerTargetNodeNameScope_;
      metaOptimizerTimeoutMs_ = other.metaOptimizerTimeoutMs_;
      autoParallel_ = other.autoParallel_ != null ? other.autoParallel_.Clone() : null;
      failOnOptimizerErrors_ = other.failOnOptimizerErrors_;
      scopedAllocatorOpts_ = other.scopedAllocatorOpts_ != null ? other.scopedAllocatorOpts_.Clone() : null;
      optimizers_ = other.optimizers_.Clone();
      customOptimizers_ = other.customOptimizers_.Clone();
      interOptimizerVerifierConfig_ = other.interOptimizerVerifierConfig_ != null ? other.interOptimizerVerifierConfig_.Clone() : null;
      postOptimizationVerifierConfig_ = other.postOptimizationVerifierConfig_ != null ? other.postOptimizationVerifierConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RewriterConfig Clone() {
      return new RewriterConfig(this);
    }

    /// <summary>Field number for the "cpu_layout_conversion" field.</summary>
    public const int CpuLayoutConversionFieldNumber = 50;
    private global::Tensorflow.RewriterConfig.Types.CpuLayout cpuLayoutConversion_ = global::Tensorflow.RewriterConfig.Types.CpuLayout.NoConversionOnCpu;
    /// <summary>
    /// CPU Conversion settings between NHCW and NCHW.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.CpuLayout CpuLayoutConversion {
      get { return cpuLayoutConversion_; }
      set {
        cpuLayoutConversion_ = value;
      }
    }

    /// <summary>Field number for the "layout_optimizer" field.</summary>
    public const int LayoutOptimizerFieldNumber = 1;
    private global::Tensorflow.RewriterConfig.Types.Toggle layoutOptimizer_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize tensor layouts (default is ON)
    /// e.g. This will try to use NCHW layout on GPU which is faster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle LayoutOptimizer {
      get { return layoutOptimizer_; }
      set {
        layoutOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "constant_folding" field.</summary>
    public const int ConstantFoldingFieldNumber = 3;
    private global::Tensorflow.RewriterConfig.Types.Toggle constantFolding_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Fold constants (default is ON)
    /// Statically infer the value of tensors when possible, and materialize the
    /// result using constants.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ConstantFolding {
      get { return constantFolding_; }
      set {
        constantFolding_ = value;
      }
    }

    /// <summary>Field number for the "shape_optimization" field.</summary>
    public const int ShapeOptimizationFieldNumber = 13;
    private global::Tensorflow.RewriterConfig.Types.Toggle shapeOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Shape optimizations (default is ON)
    /// Simplify computations made on shapes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ShapeOptimization {
      get { return shapeOptimization_; }
      set {
        shapeOptimization_ = value;
      }
    }

    /// <summary>Field number for the "remapping" field.</summary>
    public const int RemappingFieldNumber = 14;
    private global::Tensorflow.RewriterConfig.Types.Toggle remapping_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Remapping (default is ON)
    /// Remap subgraphs onto more efficient implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle Remapping {
      get { return remapping_; }
      set {
        remapping_ = value;
      }
    }

    /// <summary>Field number for the "common_subgraph_elimination" field.</summary>
    public const int CommonSubgraphEliminationFieldNumber = 24;
    private global::Tensorflow.RewriterConfig.Types.Toggle commonSubgraphElimination_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Common subgraph elimination (default is ON)
    /// e.g. Simplify arithmetic ops; merge ops with same value (like constants).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle CommonSubgraphElimination {
      get { return commonSubgraphElimination_; }
      set {
        commonSubgraphElimination_ = value;
      }
    }

    /// <summary>Field number for the "arithmetic_optimization" field.</summary>
    public const int ArithmeticOptimizationFieldNumber = 7;
    private global::Tensorflow.RewriterConfig.Types.Toggle arithmeticOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Arithmetic optimizations (default is ON)
    /// e.g. Simplify arithmetic ops; merge ops with same value (like constants).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ArithmeticOptimization {
      get { return arithmeticOptimization_; }
      set {
        arithmeticOptimization_ = value;
      }
    }

    /// <summary>Field number for the "dependency_optimization" field.</summary>
    public const int DependencyOptimizationFieldNumber = 8;
    private global::Tensorflow.RewriterConfig.Types.Toggle dependencyOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Control dependency optimizations (default is ON).
    /// Remove redundant control dependencies, which may enable other optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle DependencyOptimization {
      get { return dependencyOptimization_; }
      set {
        dependencyOptimization_ = value;
      }
    }

    /// <summary>Field number for the "loop_optimization" field.</summary>
    public const int LoopOptimizationFieldNumber = 9;
    private global::Tensorflow.RewriterConfig.Types.Toggle loopOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Loop optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle LoopOptimization {
      get { return loopOptimization_; }
      set {
        loopOptimization_ = value;
      }
    }

    /// <summary>Field number for the "function_optimization" field.</summary>
    public const int FunctionOptimizationFieldNumber = 10;
    private global::Tensorflow.RewriterConfig.Types.Toggle functionOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Function optimizations (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle FunctionOptimization {
      get { return functionOptimization_; }
      set {
        functionOptimization_ = value;
      }
    }

    /// <summary>Field number for the "debug_stripper" field.</summary>
    public const int DebugStripperFieldNumber = 11;
    private global::Tensorflow.RewriterConfig.Types.Toggle debugStripper_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Strips debug-related nodes from the graph (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle DebugStripper {
      get { return debugStripper_; }
      set {
        debugStripper_ = value;
      }
    }

    /// <summary>Field number for the "disable_model_pruning" field.</summary>
    public const int DisableModelPruningFieldNumber = 2;
    private bool disableModelPruning_;
    /// <summary>
    /// If true, don't remove unnecessary ops from the graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableModelPruning {
      get { return disableModelPruning_; }
      set {
        disableModelPruning_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_optimization" field.</summary>
    public const int ScopedAllocatorOptimizationFieldNumber = 15;
    private global::Tensorflow.RewriterConfig.Types.Toggle scopedAllocatorOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Try to allocate some independent Op outputs contiguously in order to
    /// merge or eliminate downstream Ops (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ScopedAllocatorOptimization {
      get { return scopedAllocatorOptimization_; }
      set {
        scopedAllocatorOptimization_ = value;
      }
    }

    /// <summary>Field number for the "pin_to_host_optimization" field.</summary>
    public const int PinToHostOptimizationFieldNumber = 18;
    private global::Tensorflow.RewriterConfig.Types.Toggle pinToHostOptimization_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Force small ops onto the CPU (default is OFF).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle PinToHostOptimization {
      get { return pinToHostOptimization_; }
      set {
        pinToHostOptimization_ = value;
      }
    }

    /// <summary>Field number for the "implementation_selector" field.</summary>
    public const int ImplementationSelectorFieldNumber = 22;
    private global::Tensorflow.RewriterConfig.Types.Toggle implementationSelector_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Enable the swap of kernel implementations based on the device placement
    /// (default is ON).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle ImplementationSelector {
      get { return implementationSelector_; }
      set {
        implementationSelector_ = value;
      }
    }

    /// <summary>Field number for the "auto_mixed_precision" field.</summary>
    public const int AutoMixedPrecisionFieldNumber = 23;
    private global::Tensorflow.RewriterConfig.Types.Toggle autoMixedPrecision_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize data types for CUDA (default is OFF).
    /// This will try to use float16 on GPU which is faster.
    /// Note that this can change the numerical stability of the graph and may
    /// require the use of loss scaling to maintain model convergence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle AutoMixedPrecision {
      get { return autoMixedPrecision_; }
      set {
        autoMixedPrecision_ = value;
      }
    }

    /// <summary>Field number for the "auto_mixed_precision_mkl" field.</summary>
    public const int AutoMixedPrecisionMklFieldNumber = 25;
    private global::Tensorflow.RewriterConfig.Types.Toggle autoMixedPrecisionMkl_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimize data types for MKL (default is OFF).
    /// This will try to use bfloat16 on CPUs, which is faster.
    /// Note that this can change the numerical stability of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle AutoMixedPrecisionMkl {
      get { return autoMixedPrecisionMkl_; }
      set {
        autoMixedPrecisionMkl_ = value;
      }
    }

    /// <summary>Field number for the "disable_meta_optimizer" field.</summary>
    public const int DisableMetaOptimizerFieldNumber = 19;
    private bool disableMetaOptimizer_;
    /// <summary>
    /// Disable the entire meta optimizer (off by default).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool DisableMetaOptimizer {
      get { return disableMetaOptimizer_; }
      set {
        disableMetaOptimizer_ = value;
      }
    }

    /// <summary>Field number for the "use_plugin_optimizers" field.</summary>
    public const int UsePluginOptimizersFieldNumber = 28;
    private global::Tensorflow.RewriterConfig.Types.Toggle usePluginOptimizers_ = global::Tensorflow.RewriterConfig.Types.Toggle.Default;
    /// <summary>
    /// Optimizers registered by plugin (default is ON)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.Toggle UsePluginOptimizers {
      get { return usePluginOptimizers_; }
      set {
        usePluginOptimizers_ = value;
      }
    }

    /// <summary>Field number for the "meta_optimizer_iterations" field.</summary>
    public const int MetaOptimizerIterationsFieldNumber = 12;
    private global::Tensorflow.RewriterConfig.Types.NumIterationsType metaOptimizerIterations_ = global::Tensorflow.RewriterConfig.Types.NumIterationsType.DefaultNumIters;
    /// <summary>
    /// Controls how many times we run the optimizers in meta optimizer (default
    /// is once).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.NumIterationsType MetaOptimizerIterations {
      get { return metaOptimizerIterations_; }
      set {
        metaOptimizerIterations_ = value;
      }
    }

    /// <summary>Field number for the "min_graph_nodes" field.</summary>
    public const int MinGraphNodesFieldNumber = 17;
    private int minGraphNodes_;
    /// <summary>
    /// The minimum number of nodes in a graph to optimizer. For smaller graphs,
    /// optimization is skipped.
    /// 0 means the system picks an appropriate number.
    /// &lt; 0 means do not skip optimization.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinGraphNodes {
      get { return minGraphNodes_; }
      set {
        minGraphNodes_ = value;
      }
    }

    /// <summary>Field number for the "experimental_disable_compressed_tensor_optimization" field.</summary>
    public const int ExperimentalDisableCompressedTensorOptimizationFieldNumber = 26;
    private bool experimentalDisableCompressedTensorOptimization_;
    /// <summary>
    /// Disable optimizations that assume compressed tensors. Note that this flag
    /// is experimental and may be removed in the future.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExperimentalDisableCompressedTensorOptimization {
      get { return experimentalDisableCompressedTensorOptimization_; }
      set {
        experimentalDisableCompressedTensorOptimization_ = value;
      }
    }

    /// <summary>Field number for the "experimental_disable_folding_quantization_emulation" field.</summary>
    public const int ExperimentalDisableFoldingQuantizationEmulationFieldNumber = 27;
    private bool experimentalDisableFoldingQuantizationEmulation_;
    /// <summary>
    /// Disable folding quantization emulation ops such as FakeQuantWithMinMax* and
    /// QuantizeAndDequantize*. Some compilers (e.g. the TF-to-tflite converter)
    /// have to extract quantization configs (e.g. min/max range, number of bits,
    /// and per-channel) from the quantization emulation ops. Note that this flag
    /// is experimental and may be removed in the future. See b/174138564 for more
    /// details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExperimentalDisableFoldingQuantizationEmulation {
      get { return experimentalDisableFoldingQuantizationEmulation_; }
      set {
        experimentalDisableFoldingQuantizationEmulation_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimization" field.</summary>
    public const int MemoryOptimizationFieldNumber = 4;
    private global::Tensorflow.RewriterConfig.Types.MemOptType memoryOptimization_ = global::Tensorflow.RewriterConfig.Types.MemOptType.DefaultMemOpt;
    /// <summary>
    /// Configures memory optimization passes through the meta-optimizer. Has no
    /// effect on manually requested memory optimization passes in the optimizers
    /// field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.RewriterConfig.Types.MemOptType MemoryOptimization {
      get { return memoryOptimization_; }
      set {
        memoryOptimization_ = value;
      }
    }

    /// <summary>Field number for the "memory_optimizer_target_node_name_scope" field.</summary>
    public const int MemoryOptimizerTargetNodeNameScopeFieldNumber = 6;
    private string memoryOptimizerTargetNodeNameScope_ = "";
    /// <summary>
    /// A node name scope for node names which are valid outputs of recomputations.
    /// Inputs to nodes that match this scope may be recomputed (subject either to
    /// manual annotation of those input nodes or to manual annotation and
    /// heuristics depending on memory_optimization), but the nodes themselves will
    /// not be recomputed. This matches any sub-scopes as well, meaning the scope
    /// can appear not just as a top-level scope. For example, if the value is
    /// "gradients/", the default, it will match node name "gradients/foo",
    /// "foo/gradients/bar", but not "foo_gradients/"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string MemoryOptimizerTargetNodeNameScope {
      get { return memoryOptimizerTargetNodeNameScope_; }
      set {
        memoryOptimizerTargetNodeNameScope_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "meta_optimizer_timeout_ms" field.</summary>
    public const int MetaOptimizerTimeoutMsFieldNumber = 20;
    private long metaOptimizerTimeoutMs_;
    /// <summary>
    /// Maximum number of milliseconds to spend optimizing a single graph before
    /// timing out. If equal to 0 the system picks a default (currently 5 minutes).
    /// If less than 0 the optimizer will never time out.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MetaOptimizerTimeoutMs {
      get { return metaOptimizerTimeoutMs_; }
      set {
        metaOptimizerTimeoutMs_ = value;
      }
    }

    /// <summary>Field number for the "auto_parallel" field.</summary>
    public const int AutoParallelFieldNumber = 5;
    private global::Tensorflow.AutoParallelOptions autoParallel_;
    /// <summary>
    /// Configures AutoParallel optimization passes either through the
    /// meta-optimizer or when manually specified through the optimizers field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.AutoParallelOptions AutoParallel {
      get { return autoParallel_; }
      set {
        autoParallel_ = value;
      }
    }

    /// <summary>Field number for the "fail_on_optimizer_errors" field.</summary>
    public const int FailOnOptimizerErrorsFieldNumber = 21;
    private bool failOnOptimizerErrors_;
    /// <summary>
    /// If true, any optimization pass failing will cause the MetaOptimizer to
    /// stop with an error. By default - or when set to false, failing passes are
    /// skipped silently.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FailOnOptimizerErrors {
      get { return failOnOptimizerErrors_; }
      set {
        failOnOptimizerErrors_ = value;
      }
    }

    /// <summary>Field number for the "scoped_allocator_opts" field.</summary>
    public const int ScopedAllocatorOptsFieldNumber = 16;
    private global::Tensorflow.ScopedAllocatorOptions scopedAllocatorOpts_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.ScopedAllocatorOptions ScopedAllocatorOpts {
      get { return scopedAllocatorOpts_; }
      set {
        scopedAllocatorOpts_ = value;
      }
    }

    /// <summary>Field number for the "optimizers" field.</summary>
    public const int OptimizersFieldNumber = 100;
    private static readonly pb::FieldCodec<string> _repeated_optimizers_codec
        = pb::FieldCodec.ForString(802);
    private readonly pbc::RepeatedField<string> optimizers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If non-empty, will use this as an alternative way to specify a list of
    /// optimizations to turn on and the order of the optimizations (replacing the
    /// meta-optimizer).
    ///
    /// Of the RewriterConfig options, only the AutoParallel configuration options
    /// (the auto_parallel field) apply to manually requested optimization passes
    /// ("autoparallel"). Memory optimization passes ("memory") invoked here are
    /// not configurable (in contrast to memory optimization passes through the
    /// meta-optimizer) and act only on manual op annotations.
    ///
    /// Custom optimizers (see custom_optimizers) that are not part of this
    /// schedule will be run after - in the order that they were specified.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Optimizers {
      get { return optimizers_; }
    }

    /// <summary>Field number for the "custom_optimizers" field.</summary>
    public const int CustomOptimizersFieldNumber = 200;
    private static readonly pb::FieldCodec<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> _repeated_customOptimizers_codec
        = pb::FieldCodec.ForMessage(1602, global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> customOptimizers_ = new pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer>();
    /// <summary>
    /// list of CustomGraphOptimizers to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.RewriterConfig.Types.CustomGraphOptimizer> CustomOptimizers {
      get { return customOptimizers_; }
    }

    /// <summary>Field number for the "inter_optimizer_verifier_config" field.</summary>
    public const int InterOptimizerVerifierConfigFieldNumber = 300;
    private global::Tensorflow.VerifierConfig interOptimizerVerifierConfig_;
    /// <summary>
    /// VerifierConfig specifying the verifiers to be run after every optimizer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.VerifierConfig InterOptimizerVerifierConfig {
      get { return interOptimizerVerifierConfig_; }
      set {
        interOptimizerVerifierConfig_ = value;
      }
    }

    /// <summary>Field number for the "post_optimization_verifier_config" field.</summary>
    public const int PostOptimizationVerifierConfigFieldNumber = 301;
    private global::Tensorflow.VerifierConfig postOptimizationVerifierConfig_;
    /// <summary>
    /// VerifierConfig specifying the verifiers to be run at the end, after all
    /// optimizers have run.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.VerifierConfig PostOptimizationVerifierConfig {
      get { return postOptimizationVerifierConfig_; }
      set {
        postOptimizationVerifierConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RewriterConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RewriterConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CpuLayoutConversion != other.CpuLayoutConversion) return false;
      if (LayoutOptimizer != other.LayoutOptimizer) return false;
      if (ConstantFolding != other.ConstantFolding) return false;
      if (ShapeOptimization != other.ShapeOptimization) return false;
      if (Remapping != other.Remapping) return false;
      if (CommonSubgraphElimination != other.CommonSubgraphElimination) return false;
      if (ArithmeticOptimization != other.ArithmeticOptimization) return false;
      if (DependencyOptimization != other.DependencyOptimization) return false;
      if (LoopOptimization != other.LoopOptimization) return false;
      if (FunctionOptimization != other.FunctionOptimization) return false;
      if (DebugStripper != other.DebugStripper) return false;
      if (DisableModelPruning != other.DisableModelPruning) return false;
      if (ScopedAllocatorOptimization != other.ScopedAllocatorOptimization) return false;
      if (PinToHostOptimization != other.PinToHostOptimization) return false;
      if (ImplementationSelector != other.ImplementationSelector) return false;
      if (AutoMixedPrecision != other.AutoMixedPrecision) return false;
      if (AutoMixedPrecisionMkl != other.AutoMixedPrecisionMkl) return false;
      if (DisableMetaOptimizer != other.DisableMetaOptimizer) return false;
      if (UsePluginOptimizers != other.UsePluginOptimizers) return false;
      if (MetaOptimizerIterations != other.MetaOptimizerIterations) return false;
      if (MinGraphNodes != other.MinGraphNodes) return false;
      if (ExperimentalDisableCompressedTensorOptimization != other.ExperimentalDisableCompressedTensorOptimization) return false;
      if (ExperimentalDisableFoldingQuantizationEmulation != other.ExperimentalDisableFoldingQuantizationEmulation) return false;
      if (MemoryOptimization != other.MemoryOptimization) return false;
      if (MemoryOptimizerTargetNodeNameScope != other.MemoryOptimizerTargetNodeNameScope) return false;
      if (MetaOptimizerTimeoutMs != other.MetaOptimizerTimeoutMs) return false;
      if (!object.Equals(AutoParallel, other.AutoParallel)) return false;
      if (FailOnOptimizerErrors != other.FailOnOptimizerErrors) return false;
      if (!object.Equals(ScopedAllocatorOpts, other.ScopedAllocatorOpts)) return false;
      if(!optimizers_.Equals(other.optimizers_)) return false;
      if(!customOptimizers_.Equals(other.customOptimizers_)) return false;
      if (!object.Equals(InterOptimizerVerifierConfig, other.InterOptimizerVerifierConfig)) return false;
      if (!object.Equals(PostOptimizationVerifierConfig, other.PostOptimizationVerifierConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CpuLayoutConversion != global::Tensorflow.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) hash ^= CpuLayoutConversion.GetHashCode();
      if (LayoutOptimizer != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= LayoutOptimizer.GetHashCode();
      if (ConstantFolding != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= ConstantFolding.GetHashCode();
      if (ShapeOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= ShapeOptimization.GetHashCode();
      if (Remapping != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= Remapping.GetHashCode();
      if (CommonSubgraphElimination != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= CommonSubgraphElimination.GetHashCode();
      if (ArithmeticOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= ArithmeticOptimization.GetHashCode();
      if (DependencyOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= DependencyOptimization.GetHashCode();
      if (LoopOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= LoopOptimization.GetHashCode();
      if (FunctionOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= FunctionOptimization.GetHashCode();
      if (DebugStripper != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= DebugStripper.GetHashCode();
      if (DisableModelPruning != false) hash ^= DisableModelPruning.GetHashCode();
      if (ScopedAllocatorOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= ScopedAllocatorOptimization.GetHashCode();
      if (PinToHostOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= PinToHostOptimization.GetHashCode();
      if (ImplementationSelector != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= ImplementationSelector.GetHashCode();
      if (AutoMixedPrecision != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= AutoMixedPrecision.GetHashCode();
      if (AutoMixedPrecisionMkl != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= AutoMixedPrecisionMkl.GetHashCode();
      if (DisableMetaOptimizer != false) hash ^= DisableMetaOptimizer.GetHashCode();
      if (UsePluginOptimizers != global::Tensorflow.RewriterConfig.Types.Toggle.Default) hash ^= UsePluginOptimizers.GetHashCode();
      if (MetaOptimizerIterations != global::Tensorflow.RewriterConfig.Types.NumIterationsType.DefaultNumIters) hash ^= MetaOptimizerIterations.GetHashCode();
      if (MinGraphNodes != 0) hash ^= MinGraphNodes.GetHashCode();
      if (ExperimentalDisableCompressedTensorOptimization != false) hash ^= ExperimentalDisableCompressedTensorOptimization.GetHashCode();
      if (ExperimentalDisableFoldingQuantizationEmulation != false) hash ^= ExperimentalDisableFoldingQuantizationEmulation.GetHashCode();
      if (MemoryOptimization != global::Tensorflow.RewriterConfig.Types.MemOptType.DefaultMemOpt) hash ^= MemoryOptimization.GetHashCode();
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) hash ^= MemoryOptimizerTargetNodeNameScope.GetHashCode();
      if (MetaOptimizerTimeoutMs != 0L) hash ^= MetaOptimizerTimeoutMs.GetHashCode();
      if (autoParallel_ != null) hash ^= AutoParallel.GetHashCode();
      if (FailOnOptimizerErrors != false) hash ^= FailOnOptimizerErrors.GetHashCode();
      if (scopedAllocatorOpts_ != null) hash ^= ScopedAllocatorOpts.GetHashCode();
      hash ^= optimizers_.GetHashCode();
      hash ^= customOptimizers_.GetHashCode();
      if (interOptimizerVerifierConfig_ != null) hash ^= InterOptimizerVerifierConfig.GetHashCode();
      if (postOptimizationVerifierConfig_ != null) hash ^= PostOptimizationVerifierConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LayoutOptimizer != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(8);
        output.WriteEnum((int) LayoutOptimizer);
      }
      if (DisableModelPruning != false) {
        output.WriteRawTag(16);
        output.WriteBool(DisableModelPruning);
      }
      if (ConstantFolding != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(24);
        output.WriteEnum((int) ConstantFolding);
      }
      if (MemoryOptimization != global::Tensorflow.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        output.WriteRawTag(32);
        output.WriteEnum((int) MemoryOptimization);
      }
      if (autoParallel_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(AutoParallel);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(MemoryOptimizerTargetNodeNameScope);
      }
      if (ArithmeticOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(56);
        output.WriteEnum((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DependencyOptimization);
      }
      if (LoopOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(72);
        output.WriteEnum((int) LoopOptimization);
      }
      if (FunctionOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(80);
        output.WriteEnum((int) FunctionOptimization);
      }
      if (DebugStripper != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(88);
        output.WriteEnum((int) DebugStripper);
      }
      if (MetaOptimizerIterations != global::Tensorflow.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        output.WriteRawTag(96);
        output.WriteEnum((int) MetaOptimizerIterations);
      }
      if (ShapeOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(104);
        output.WriteEnum((int) ShapeOptimization);
      }
      if (Remapping != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(112);
        output.WriteEnum((int) Remapping);
      }
      if (ScopedAllocatorOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(120);
        output.WriteEnum((int) ScopedAllocatorOptimization);
      }
      if (scopedAllocatorOpts_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(ScopedAllocatorOpts);
      }
      if (MinGraphNodes != 0) {
        output.WriteRawTag(136, 1);
        output.WriteInt32(MinGraphNodes);
      }
      if (PinToHostOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) PinToHostOptimization);
      }
      if (DisableMetaOptimizer != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(DisableMetaOptimizer);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        output.WriteRawTag(160, 1);
        output.WriteInt64(MetaOptimizerTimeoutMs);
      }
      if (FailOnOptimizerErrors != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(FailOnOptimizerErrors);
      }
      if (ImplementationSelector != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(176, 1);
        output.WriteEnum((int) ImplementationSelector);
      }
      if (AutoMixedPrecision != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(184, 1);
        output.WriteEnum((int) AutoMixedPrecision);
      }
      if (CommonSubgraphElimination != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(192, 1);
        output.WriteEnum((int) CommonSubgraphElimination);
      }
      if (AutoMixedPrecisionMkl != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(200, 1);
        output.WriteEnum((int) AutoMixedPrecisionMkl);
      }
      if (ExperimentalDisableCompressedTensorOptimization != false) {
        output.WriteRawTag(208, 1);
        output.WriteBool(ExperimentalDisableCompressedTensorOptimization);
      }
      if (ExperimentalDisableFoldingQuantizationEmulation != false) {
        output.WriteRawTag(216, 1);
        output.WriteBool(ExperimentalDisableFoldingQuantizationEmulation);
      }
      if (UsePluginOptimizers != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        output.WriteRawTag(224, 1);
        output.WriteEnum((int) UsePluginOptimizers);
      }
      if (CpuLayoutConversion != global::Tensorflow.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        output.WriteRawTag(144, 3);
        output.WriteEnum((int) CpuLayoutConversion);
      }
      optimizers_.WriteTo(output, _repeated_optimizers_codec);
      customOptimizers_.WriteTo(output, _repeated_customOptimizers_codec);
      if (interOptimizerVerifierConfig_ != null) {
        output.WriteRawTag(226, 18);
        output.WriteMessage(InterOptimizerVerifierConfig);
      }
      if (postOptimizationVerifierConfig_ != null) {
        output.WriteRawTag(234, 18);
        output.WriteMessage(PostOptimizationVerifierConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CpuLayoutConversion != global::Tensorflow.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CpuLayoutConversion);
      }
      if (LayoutOptimizer != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LayoutOptimizer);
      }
      if (ConstantFolding != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ConstantFolding);
      }
      if (ShapeOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ShapeOptimization);
      }
      if (Remapping != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Remapping);
      }
      if (CommonSubgraphElimination != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) CommonSubgraphElimination);
      }
      if (ArithmeticOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ArithmeticOptimization);
      }
      if (DependencyOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DependencyOptimization);
      }
      if (LoopOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LoopOptimization);
      }
      if (FunctionOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FunctionOptimization);
      }
      if (DebugStripper != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DebugStripper);
      }
      if (DisableModelPruning != false) {
        size += 1 + 1;
      }
      if (ScopedAllocatorOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScopedAllocatorOptimization);
      }
      if (PinToHostOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) PinToHostOptimization);
      }
      if (ImplementationSelector != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ImplementationSelector);
      }
      if (AutoMixedPrecision != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AutoMixedPrecision);
      }
      if (AutoMixedPrecisionMkl != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) AutoMixedPrecisionMkl);
      }
      if (DisableMetaOptimizer != false) {
        size += 2 + 1;
      }
      if (UsePluginOptimizers != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) UsePluginOptimizers);
      }
      if (MetaOptimizerIterations != global::Tensorflow.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MetaOptimizerIterations);
      }
      if (MinGraphNodes != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MinGraphNodes);
      }
      if (ExperimentalDisableCompressedTensorOptimization != false) {
        size += 2 + 1;
      }
      if (ExperimentalDisableFoldingQuantizationEmulation != false) {
        size += 2 + 1;
      }
      if (MemoryOptimization != global::Tensorflow.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MemoryOptimization);
      }
      if (MemoryOptimizerTargetNodeNameScope.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(MemoryOptimizerTargetNodeNameScope);
      }
      if (MetaOptimizerTimeoutMs != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(MetaOptimizerTimeoutMs);
      }
      if (autoParallel_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AutoParallel);
      }
      if (FailOnOptimizerErrors != false) {
        size += 2 + 1;
      }
      if (scopedAllocatorOpts_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScopedAllocatorOpts);
      }
      size += optimizers_.CalculateSize(_repeated_optimizers_codec);
      size += customOptimizers_.CalculateSize(_repeated_customOptimizers_codec);
      if (interOptimizerVerifierConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(InterOptimizerVerifierConfig);
      }
      if (postOptimizationVerifierConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(PostOptimizationVerifierConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RewriterConfig other) {
      if (other == null) {
        return;
      }
      if (other.CpuLayoutConversion != global::Tensorflow.RewriterConfig.Types.CpuLayout.NoConversionOnCpu) {
        CpuLayoutConversion = other.CpuLayoutConversion;
      }
      if (other.LayoutOptimizer != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        LayoutOptimizer = other.LayoutOptimizer;
      }
      if (other.ConstantFolding != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        ConstantFolding = other.ConstantFolding;
      }
      if (other.ShapeOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        ShapeOptimization = other.ShapeOptimization;
      }
      if (other.Remapping != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        Remapping = other.Remapping;
      }
      if (other.CommonSubgraphElimination != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        CommonSubgraphElimination = other.CommonSubgraphElimination;
      }
      if (other.ArithmeticOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        ArithmeticOptimization = other.ArithmeticOptimization;
      }
      if (other.DependencyOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        DependencyOptimization = other.DependencyOptimization;
      }
      if (other.LoopOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        LoopOptimization = other.LoopOptimization;
      }
      if (other.FunctionOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        FunctionOptimization = other.FunctionOptimization;
      }
      if (other.DebugStripper != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        DebugStripper = other.DebugStripper;
      }
      if (other.DisableModelPruning != false) {
        DisableModelPruning = other.DisableModelPruning;
      }
      if (other.ScopedAllocatorOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        ScopedAllocatorOptimization = other.ScopedAllocatorOptimization;
      }
      if (other.PinToHostOptimization != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        PinToHostOptimization = other.PinToHostOptimization;
      }
      if (other.ImplementationSelector != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        ImplementationSelector = other.ImplementationSelector;
      }
      if (other.AutoMixedPrecision != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        AutoMixedPrecision = other.AutoMixedPrecision;
      }
      if (other.AutoMixedPrecisionMkl != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        AutoMixedPrecisionMkl = other.AutoMixedPrecisionMkl;
      }
      if (other.DisableMetaOptimizer != false) {
        DisableMetaOptimizer = other.DisableMetaOptimizer;
      }
      if (other.UsePluginOptimizers != global::Tensorflow.RewriterConfig.Types.Toggle.Default) {
        UsePluginOptimizers = other.UsePluginOptimizers;
      }
      if (other.MetaOptimizerIterations != global::Tensorflow.RewriterConfig.Types.NumIterationsType.DefaultNumIters) {
        MetaOptimizerIterations = other.MetaOptimizerIterations;
      }
      if (other.MinGraphNodes != 0) {
        MinGraphNodes = other.MinGraphNodes;
      }
      if (other.ExperimentalDisableCompressedTensorOptimization != false) {
        ExperimentalDisableCompressedTensorOptimization = other.ExperimentalDisableCompressedTensorOptimization;
      }
      if (other.ExperimentalDisableFoldingQuantizationEmulation != false) {
        ExperimentalDisableFoldingQuantizationEmulation = other.ExperimentalDisableFoldingQuantizationEmulation;
      }
      if (other.MemoryOptimization != global::Tensorflow.RewriterConfig.Types.MemOptType.DefaultMemOpt) {
        MemoryOptimization = other.MemoryOptimization;
      }
      if (other.MemoryOptimizerTargetNodeNameScope.Length != 0) {
        MemoryOptimizerTargetNodeNameScope = other.MemoryOptimizerTargetNodeNameScope;
      }
      if (other.MetaOptimizerTimeoutMs != 0L) {
        MetaOptimizerTimeoutMs = other.MetaOptimizerTimeoutMs;
      }
      if (other.autoParallel_ != null) {
        if (autoParallel_ == null) {
          AutoParallel = new global::Tensorflow.AutoParallelOptions();
        }
        AutoParallel.MergeFrom(other.AutoParallel);
      }
      if (other.FailOnOptimizerErrors != false) {
        FailOnOptimizerErrors = other.FailOnOptimizerErrors;
      }
      if (other.scopedAllocatorOpts_ != null) {
        if (scopedAllocatorOpts_ == null) {
          ScopedAllocatorOpts = new global::Tensorflow.ScopedAllocatorOptions();
        }
        ScopedAllocatorOpts.MergeFrom(other.ScopedAllocatorOpts);
      }
      optimizers_.Add(other.optimizers_);
      customOptimizers_.Add(other.customOptimizers_);
      if (other.interOptimizerVerifierConfig_ != null) {
        if (interOptimizerVerifierConfig_ == null) {
          InterOptimizerVerifierConfig = new global::Tensorflow.VerifierConfig();
        }
        InterOptimizerVerifierConfig.MergeFrom(other.InterOptimizerVerifierConfig);
      }
      if (other.postOptimizationVerifierConfig_ != null) {
        if (postOptimizationVerifierConfig_ == null) {
          PostOptimizationVerifierConfig = new global::Tensorflow.VerifierConfig();
        }
        PostOptimizationVerifierConfig.MergeFrom(other.PostOptimizationVerifierConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            LayoutOptimizer = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 16: {
            DisableModelPruning = input.ReadBool();
            break;
          }
          case 24: {
            ConstantFolding = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 32: {
            MemoryOptimization = (global::Tensorflow.RewriterConfig.Types.MemOptType) input.ReadEnum();
            break;
          }
          case 42: {
            if (autoParallel_ == null) {
              AutoParallel = new global::Tensorflow.AutoParallelOptions();
            }
            input.ReadMessage(AutoParallel);
            break;
          }
          case 50: {
            MemoryOptimizerTargetNodeNameScope = input.ReadString();
            break;
          }
          case 56: {
            ArithmeticOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 64: {
            DependencyOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 72: {
            LoopOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 80: {
            FunctionOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 88: {
            DebugStripper = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 96: {
            MetaOptimizerIterations = (global::Tensorflow.RewriterConfig.Types.NumIterationsType) input.ReadEnum();
            break;
          }
          case 104: {
            ShapeOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 112: {
            Remapping = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 120: {
            ScopedAllocatorOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 130: {
            if (scopedAllocatorOpts_ == null) {
              ScopedAllocatorOpts = new global::Tensorflow.ScopedAllocatorOptions();
            }
            input.ReadMessage(ScopedAllocatorOpts);
            break;
          }
          case 136: {
            MinGraphNodes = input.ReadInt32();
            break;
          }
          case 144: {
            PinToHostOptimization = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 152: {
            DisableMetaOptimizer = input.ReadBool();
            break;
          }
          case 160: {
            MetaOptimizerTimeoutMs = input.ReadInt64();
            break;
          }
          case 168: {
            FailOnOptimizerErrors = input.ReadBool();
            break;
          }
          case 176: {
            ImplementationSelector = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 184: {
            AutoMixedPrecision = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 192: {
            CommonSubgraphElimination = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 200: {
            AutoMixedPrecisionMkl = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 208: {
            ExperimentalDisableCompressedTensorOptimization = input.ReadBool();
            break;
          }
          case 216: {
            ExperimentalDisableFoldingQuantizationEmulation = input.ReadBool();
            break;
          }
          case 224: {
            UsePluginOptimizers = (global::Tensorflow.RewriterConfig.Types.Toggle) input.ReadEnum();
            break;
          }
          case 400: {
            CpuLayoutConversion = (global::Tensorflow.RewriterConfig.Types.CpuLayout) input.ReadEnum();
            break;
          }
          case 802: {
            optimizers_.AddEntriesFrom(input, _repeated_optimizers_codec);
            break;
          }
          case 1602: {
            customOptimizers_.AddEntriesFrom(input, _repeated_customOptimizers_codec);
            break;
          }
          case 2402: {
            if (interOptimizerVerifierConfig_ == null) {
              InterOptimizerVerifierConfig = new global::Tensorflow.VerifierConfig();
            }
            input.ReadMessage(InterOptimizerVerifierConfig);
            break;
          }
          case 2410: {
            if (postOptimizationVerifierConfig_ == null) {
              PostOptimizationVerifierConfig = new global::Tensorflow.VerifierConfig();
            }
            input.ReadMessage(PostOptimizationVerifierConfig);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the RewriterConfig message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Toggle {
        [pbr::OriginalName("DEFAULT")] Default = 0,
        [pbr::OriginalName("ON")] On = 1,
        [pbr::OriginalName("OFF")] Off = 2,
        /// <summary>
        /// Enable some aggressive optimizations that use assumptions that TF graphs
        /// may break. For example, assume the shape of a placeholder matches its
        /// actual feed.
        /// </summary>
        [pbr::OriginalName("AGGRESSIVE")] Aggressive = 3,
      }

      /// <summary>
      /// Enum for layout conversion between NCHW and NHWC on CPU. Default is OFF.
      /// </summary>
      public enum CpuLayout {
        [pbr::OriginalName("NO_CONVERSION_ON_CPU")] NoConversionOnCpu = 0,
        [pbr::OriginalName("NCHW_TO_NHWC")] NchwToNhwc = 1,
        [pbr::OriginalName("NHWC_TO_NCHW")] NhwcToNchw = 2,
      }

      /// <summary>
      /// Enum controlling the number of times to run optimizers. The default is to
      /// run them twice.
      /// </summary>
      public enum NumIterationsType {
        [pbr::OriginalName("DEFAULT_NUM_ITERS")] DefaultNumIters = 0,
        [pbr::OriginalName("ONE")] One = 1,
        [pbr::OriginalName("TWO")] Two = 2,
      }

      public enum MemOptType {
        /// <summary>
        /// The default setting (SCHEDULING and SWAPPING HEURISTICS only)
        /// </summary>
        [pbr::OriginalName("DEFAULT_MEM_OPT")] DefaultMemOpt = 0,
        /// <summary>
        /// Disabled in the meta-optimizer.
        /// </summary>
        [pbr::OriginalName("NO_MEM_OPT")] NoMemOpt = 1,
        /// <summary>
        /// Driven by manual op-level annotations.
        /// </summary>
        [pbr::OriginalName("MANUAL")] Manual = 2,
        /// <summary>
        /// Swapping heuristic will move a tensor from the GPU to the CPU and move
        /// it back when needed to reduce peak memory usage.
        /// </summary>
        [pbr::OriginalName("SWAPPING_HEURISTICS")] SwappingHeuristics = 4,
        /// <summary>
        /// Recomputation heuristics will recompute ops (such as Relu activation)
        /// during backprop instead of storing them, reducing peak memory usage.
        /// </summary>
        [pbr::OriginalName("RECOMPUTATION_HEURISTICS")] RecomputationHeuristics = 5,
        /// <summary>
        /// Scheduling will split big ops such as AddN and try to enforce a schedule
        /// of the new computations that decreases peak memory usage.
        /// </summary>
        [pbr::OriginalName("SCHEDULING_HEURISTICS")] SchedulingHeuristics = 6,
        /// <summary>
        /// Use any combination of swapping and recomputation heuristics.
        /// </summary>
        [pbr::OriginalName("HEURISTICS")] Heuristics = 3,
      }

      /// <summary>
      /// Message to describe custom graph optimizer and its parameters
      /// </summary>
      public sealed partial class CustomGraphOptimizer : pb::IMessage<CustomGraphOptimizer> {
        private static readonly pb::MessageParser<CustomGraphOptimizer> _parser = new pb::MessageParser<CustomGraphOptimizer>(() => new CustomGraphOptimizer());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CustomGraphOptimizer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.RewriterConfig.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer(CustomGraphOptimizer other) : this() {
          name_ = other.name_;
          parameterMap_ = other.parameterMap_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CustomGraphOptimizer Clone() {
          return new CustomGraphOptimizer(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "parameter_map" field.</summary>
        public const int ParameterMapFieldNumber = 2;
        private static readonly pbc::MapField<string, global::Tensorflow.AttrValue>.Codec _map_parameterMap_codec
            = new pbc::MapField<string, global::Tensorflow.AttrValue>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Tensorflow.AttrValue.Parser), 18);
        private readonly pbc::MapField<string, global::Tensorflow.AttrValue> parameterMap_ = new pbc::MapField<string, global::Tensorflow.AttrValue>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::MapField<string, global::Tensorflow.AttrValue> ParameterMap {
          get { return parameterMap_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CustomGraphOptimizer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CustomGraphOptimizer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!ParameterMap.Equals(other.ParameterMap)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= ParameterMap.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          parameterMap_.WriteTo(output, _map_parameterMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += parameterMap_.CalculateSize(_map_parameterMap_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CustomGraphOptimizer other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          parameterMap_.Add(other.parameterMap_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                parameterMap_.AddEntriesFrom(input, _map_parameterMap_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
